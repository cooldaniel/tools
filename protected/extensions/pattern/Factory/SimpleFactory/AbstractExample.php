<?php
/**
 * 本文档展示了简单工厂模式的示意性(抽象)示例.
 * @version 2011.09.16
 * @author lsx
 */

/**
 * 抽象产品角色示意接口.
 * 该抽象产品角色可以使用接口或者抽象类来实现,这里仅选用接口方式.
 * 该接口主要目的是给所有的具体产品类提供一个共同的类型，在最简单的情况下，可以简化为一个标识接口。
 * 所谓标识接口，就是没有声明任何方法的空接口。
 */
interface Product
{
	
}

/**
 * 代表具体产品角色的示意类.
 * 该具体产品角色类在此仅代表一种具体的产品,在实际应用中这样的类可以根据多种不同的具体产品而有多个.
 */
class ConcreteProduct implements Product
{
	public function __construct()
	{
		
	}
}

/**
 * 示意性工厂类.
 * 该工厂类使用一个静态方法创建了一个新的具体产品的实例并返还给调用者.
 * 一个工厂类可以有多个工厂方法,具体可根据实际应用进行设计.
 */
class Creator
{
	public static function factory()
	{
		return new ConcreteProduct();
	}
}

/**
 * 附加说明:
 * 在实际的系统中,产品可以形成负责的等级结构,其中可能有多个抽象类和具体类.此时,简单工厂模式采用以不变应万变的策略,一律使用同一个工厂类.
 * 客户端对产品和工厂类的关系属于一般依赖关系,工厂类对产品的关系属于创建依赖关系.
 * 这样做的好处是设计简单,产品类的等级结构不会反映到工厂类中来,从而产品类的等级结构变化不会影响到工厂类.
 * 这样做的确定是增加新的产品必将导致工厂类的修改.
 * 关于抽象产品角色该使用接口还是抽象类,请参考其它详细资料.
 * 
 * 简单工厂模式在特定情况下可以简化为以下几种形式:
 * (1)如果系统仅有一个具体产品角色,那么可以省略抽象产品角色.使用这种方式时应该在很肯定这种情况不会有太大的变动可能.
 * (2)有时可以将工厂角色和抽象产品角色合并,即使得抽象产品角色同时担任工厂角色.
 * (3)三个角色合并,此时,这个具体产品类为自身的工厂,自行创建自己的实例.这种简化的简单工厂模式与单例模式以及多例模式有相似之处,但并不相等.
 * 具体请参考其它详细资料.
 */

/**
 * 抽象产品角色该使用接口还是抽象类的分析:
 * P137.
 */

/**
 * 将三种角色合并的简单工厂模式与单例模式和多例模式
 */
?>